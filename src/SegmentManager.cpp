/*
 * Project:			Malflare
 * Authors:			Dominic Fischer / Daniel Jordi
 * Date:			14.06.2011
 * Dependencies:
 */

#include "SegmentManager.h"

using namespace std;

/**
 * Variable initialization
 */
SegmentManager *SegmentManager::instance = NULL;
int SegmentManager::segment_number = 0;

/**
 * Constructor
 */
SegmentManager::SegmentManager() {
	migrate_segments();
}

/**
 * Sigleton construct
 */
SegmentManager * SegmentManager::Instance() {
	if (!instance) {
		instance = new SegmentManager();
	}
	return instance;
}

/**
 * Migrate existing segments (generated by IDA) to structures we control
 */
void SegmentManager::migrate_segments() {
	char name[128];

	for (int i = 0; i < get_segm_qty(); i++) {
		segment_t *s = getnseg(i);
		get_segm_name(s, name, sizeof(name));
		name[0] = '.';
		//msg("SegMan: Found seg '%s' from 0x%08x-0x%08x\n", name, s->startEA, s->endEA);
		segments.push_back(Segment(name));
	}
}

/**
 * Find an overlapping or an adjacent segment
 * @param start address of the segment
 * @param length length of the segment
 * @return reference to the segment
 */
Segment * SegmentManager::get_segment(uint32 start, uint32 length) {
	list<Segment>::iterator it;
	Segment * seg = NULL;
	Segment * near = NULL;

	for (it = segments.begin(); it != segments.end(); ++it) {
		if (it->get_start_address() <= start && it->get_end_address() > start) {
			//start in seg
			seg = &(*it);
		}

		if (it->get_start_address() <= (start + length)
				&& it->get_end_address() >= (start + length)) {
			// end in seg
			seg = &(*it);
		}

		if (it->get_end_address() == start || it->get_start_address() == start
				+ length) {
			near = &(*it);
		}

		// break when we found the right
		if (seg != NULL) {
			break;
		}
	}

	// We didn't found a matching segment, but one which is near
	if (seg == NULL && near != NULL) {
		seg = near;
	}

	return seg;
}

/**
 * Creates a new segment ".mft-X" and add it to our internal list
 * @return reference to the segment
 */
Segment * SegmentManager::create_new_segment() {
	char name[128];
	name[0] = 0;

	qsnprintf(name, sizeof(name), ".mft-%d", segment_number++);

	segments.push_back(Segment(name));
	return &segments.back();
}

/**
 * Writes data
 * @param start address of the data
 * @param data reference to the data
 * @param length of the data
 * @param backup_old_data if true, the data has been backuped
 * @return if true, the data has been written correctly
 */
bool SegmentManager::write_data(uint32 start, const char* data, uint32 length,
		bool backup_old_data, bool print_log) {
	Segment *s = get_segment(start, length);

	if (s == NULL) {
		s = create_new_segment();
	}
	return s->write_data(start, data, length, backup_old_data, print_log);
}

/**
 * Restores data
 * @param start address of the data
 * @param length of the data
 * @return if true, the data has been restored correctly
 */
bool SegmentManager::restore_data(uint32 start, uint32 length, bool print_log) {
	Segment *s = get_segment(start, length);
	bool ret = false;

	if (s != NULL) {
		ret = s->restore_data(start, length, print_log);
	}
	return ret;
}

/**
 * For debuging purposes, print out a segment
 * @param s reference to the segment
 */
void SegmentManager::print_segment(Segment *s) {
	if (s == NULL) {
		return;
	}
	msg("Segment: 0x%08x-0x%08x\n", s->get_start_address(),
			s->get_end_address());
}
